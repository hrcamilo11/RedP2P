#!/usr/bin/env python3
"""
Script de testing para las funcionalidades de la Fase 2
"""

import asyncio
import aiohttp
import json
import time
import sys
import os
from typing import Dict, Any

# Agregar el directorio src al path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'src', 'central-server'))

class Phase2Tester:
    """Tester para funcionalidades de la Fase 2"""
    
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.session = None
        self.results = []
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def test_rate_limiting(self):
        """Prueba el rate limiting"""
        print("üß™ Probando Rate Limiting...")
        
        try:
            # Hacer muchas peticiones r√°pidas
            tasks = []
            for i in range(150):  # M√°s del l√≠mite de 100
                task = self.session.get(f"{self.base_url}/api/health")
                tasks.append(task)
            
            responses = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Contar respuestas exitosas vs rate limited
            success_count = 0
            rate_limited_count = 0
            
            for response in responses:
                if isinstance(response, aiohttp.ClientResponse):
                    if response.status == 200:
                        success_count += 1
                    elif response.status == 429:
                        rate_limited_count += 1
                    await response.release()
            
            print(f"   ‚úÖ Respuestas exitosas: {success_count}")
            print(f"   ‚ö†Ô∏è  Rate limited: {rate_limited_count}")
            
            if rate_limited_count > 0:
                print("   ‚úÖ Rate limiting funcionando correctamente")
                return True
            else:
                print("   ‚ùå Rate limiting no est√° funcionando")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Error probando rate limiting: {e}")
            return False
    
    async def test_monitoring_endpoints(self):
        """Prueba los endpoints de monitoreo"""
        print("üß™ Probando Endpoints de Monitoreo...")
        
        endpoints = [
            "/api/monitoring/health",
            "/api/monitoring/metrics",
            "/api/monitoring/history",
            "/api/monitoring/averages"
        ]
        
        results = []
        
        for endpoint in endpoints:
            try:
                async with self.session.get(f"{self.base_url}{endpoint}") as response:
                    if response.status == 200:
                        data = await response.json()
                        print(f"   ‚úÖ {endpoint}: OK")
                        results.append(True)
                    else:
                        print(f"   ‚ùå {endpoint}: Status {response.status}")
                        results.append(False)
            except Exception as e:
                print(f"   ‚ùå {endpoint}: Error {e}")
                results.append(False)
        
        return all(results)
    
    async def test_file_validation(self):
        """Prueba la validaci√≥n de archivos"""
        print("üß™ Probando Validaci√≥n de Archivos...")
        
        # Crear archivo de prueba
        test_file_content = b"Test file content for validation"
        
        try:
            # Crear archivo temporal
            import tempfile
            with tempfile.NamedTemporaryFile(delete=False, suffix=".txt") as f:
                f.write(test_file_content)
                temp_file_path = f.name
            
            # Probar subida de archivo v√°lido
            data = aiohttp.FormData()
            data.add_field('file', open(temp_file_path, 'rb'), filename='test.txt')
            data.add_field('target_peer', 'peer1')
            
            async with self.session.post(f"{self.base_url}/api/transfers/upload-file", data=data) as response:
                if response.status == 200:
                    print("   ‚úÖ Subida de archivo v√°lido: OK")
                    valid_upload = True
                else:
                    print(f"   ‚ùå Subida de archivo v√°lido: Status {response.status}")
                    valid_upload = False
            
            # Probar subida de archivo inv√°lido (extensi√≥n no permitida)
            data = aiohttp.FormData()
            data.add_field('file', open(temp_file_path, 'rb'), filename='test.exe')
            data.add_field('target_peer', 'peer1')
            
            async with self.session.post(f"{self.base_url}/api/transfers/upload-file", data=data) as response:
                if response.status == 400:
                    print("   ‚úÖ Validaci√≥n de extensi√≥n: OK")
                    validation_working = True
                else:
                    print(f"   ‚ùå Validaci√≥n de extensi√≥n: Status {response.status}")
                    validation_working = False
            
            # Limpiar archivo temporal
            os.unlink(temp_file_path)
            
            return valid_upload and validation_working
            
        except Exception as e:
            print(f"   ‚ùå Error probando validaci√≥n de archivos: {e}")
            return False
    
    async def test_pagination(self):
        """Prueba la paginaci√≥n"""
        print("üß™ Probando Paginaci√≥n...")
        
        try:
            # Probar paginaci√≥n en archivos de peer
            async with self.session.get(f"{self.base_url}/api/files/peer/peer1?page=1&limit=10") as response:
                if response.status == 200:
                    data = await response.json()
                    print(f"   ‚úÖ Paginaci√≥n b√°sica: OK (obtenidos {len(data)} archivos)")
                    pagination_working = True
                else:
                    print(f"   ‚ùå Paginaci√≥n b√°sica: Status {response.status}")
                    pagination_working = False
            
            # Probar par√°metros inv√°lidos
            async with self.session.get(f"{self.base_url}/api/files/peer/peer1?page=0&limit=200") as response:
                if response.status == 200:
                    data = await response.json()
                    # Deber√≠a usar valores por defecto
                    print(f"   ‚úÖ Validaci√≥n de par√°metros: OK")
                    validation_working = True
                else:
                    print(f"   ‚ùå Validaci√≥n de par√°metros: Status {response.status}")
                    validation_working = False
            
            return pagination_working and validation_working
            
        except Exception as e:
            print(f"   ‚ùå Error probando paginaci√≥n: {e}")
            return False
    
    async def test_cors_headers(self):
        """Prueba los headers CORS"""
        print("üß™ Probando Headers CORS...")
        
        try:
            # Hacer petici√≥n OPTIONS para probar CORS
            async with self.session.options(f"{self.base_url}/api/health") as response:
                headers = response.headers
                
                # Verificar headers CORS
                cors_headers = [
                    'Access-Control-Allow-Origin',
                    'Access-Control-Allow-Methods',
                    'Access-Control-Allow-Headers'
                ]
                
                missing_headers = []
                for header in cors_headers:
                    if header not in headers:
                        missing_headers.append(header)
                
                if not missing_headers:
                    print("   ‚úÖ Headers CORS: OK")
                    return True
                else:
                    print(f"   ‚ùå Headers CORS faltantes: {missing_headers}")
                    return False
                    
        except Exception as e:
            print(f"   ‚ùå Error probando CORS: {e}")
            return False
    
    async def test_system_health(self):
        """Prueba la salud general del sistema"""
        print("üß™ Probando Salud del Sistema...")
        
        try:
            # Probar endpoint de salud
            async with self.session.get(f"{self.base_url}/api/health") as response:
                if response.status == 200:
                    data = await response.json()
                    print(f"   ‚úÖ Health check: OK - {data.get('status', 'unknown')}")
                    health_ok = True
                else:
                    print(f"   ‚ùå Health check: Status {response.status}")
                    health_ok = False
            
            # Probar estad√≠sticas
            async with self.session.get(f"{self.base_url}/api/stats") as response:
                if response.status == 200:
                    data = await response.json()
                    print(f"   ‚úÖ Stats: OK - {data.get('total_peers', 0)} peers, {data.get('total_files', 0)} files")
                    stats_ok = True
                else:
                    print(f"   ‚ùå Stats: Status {response.status}")
                    stats_ok = False
            
            return health_ok and stats_ok
            
        except Exception as e:
            print(f"   ‚ùå Error probando salud del sistema: {e}")
            return False
    
    async def run_all_tests(self):
        """Ejecuta todas las pruebas"""
        print("üöÄ INICIANDO PRUEBAS DE FASE 2")
        print("=" * 50)
        
        tests = [
            ("Salud del Sistema", self.test_system_health),
            ("Headers CORS", self.test_cors_headers),
            ("Paginaci√≥n", self.test_pagination),
            ("Validaci√≥n de Archivos", self.test_file_validation),
            ("Endpoints de Monitoreo", self.test_monitoring_endpoints),
            ("Rate Limiting", self.test_rate_limiting),
        ]
        
        results = []
        
        for test_name, test_func in tests:
            print(f"\nüìã {test_name}")
            print("-" * 30)
            
            try:
                result = await test_func()
                results.append((test_name, result))
                
                if result:
                    print(f"‚úÖ {test_name}: PAS√ì")
                else:
                    print(f"‚ùå {test_name}: FALL√ì")
                    
            except Exception as e:
                print(f"‚ùå {test_name}: ERROR - {e}")
                results.append((test_name, False))
        
        # Resumen
        print("\n" + "=" * 50)
        print("üìä RESUMEN DE PRUEBAS")
        print("=" * 50)
        
        passed = sum(1 for _, result in results if result)
        total = len(results)
        
        for test_name, result in results:
            status = "‚úÖ PAS√ì" if result else "‚ùå FALL√ì"
            print(f"{status} - {test_name}")
        
        print(f"\nüéØ Resultado: {passed}/{total} pruebas pasaron")
        
        if passed == total:
            print("üéâ ¬°Todas las pruebas de la Fase 2 pasaron!")
            return True
        else:
            print("‚ö†Ô∏è  Algunas pruebas fallaron. Revisar la implementaci√≥n.")
            return False

async def main():
    """Funci√≥n principal"""
    print("üß™ TESTER DE FUNCIONALIDADES FASE 2")
    print("RedP2P - Sistema P2P Distribuido")
    print()
    
    async with Phase2Tester() as tester:
        success = await tester.run_all_tests()
        return 0 if success else 1

if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
